from fastapi import FastAPI, HTTPException, Request
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import yt_dlp
import os
import subprocess
import re
import json
from datetime import datetime
from urllib.request import Request, urlopen
from fastapi.staticfiles import StaticFiles
import sys

app = FastAPI()

# Configuração CORS
origins = [
    "http://localhost:5173",
    "http://localhost:3000",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    import traceback
    error_msg = f"VALIDATION ERROR: {exc.errors()}\n"
    print(error_msg)
    try:
        with open(os.path.join(get_base_dir(), "debug_validation.txt"), "w", encoding="utf-8") as f:
            f.write(error_msg)
    except:
        pass
    return JSONResponse(status_code=422, content={"detail": exc.errors()})

from typing import Optional

# Modelos
class DownloadRequest(BaseModel):
    url: str
    quality: str = "best"
    format: str = "mp3"
    mode: str = "audio"
    playlist: bool = False
    start_time: Optional[str] = None # "00:00"
    end_time: Optional[str] = None   # "00:00"
    pitch: int = 0         # -12 to +12
    speed: float = 1.0     # 0.5 to 2.0
    title: Optional[str] = None
    artist: Optional[str] = None
    cover_path: Optional[str] = None
    eq_preset: Optional[str] = None # 'bass', 'soft', 'treble', 'vocal'

EQ_PRESETS = {
    'bass': 'equalizer=f=60:width_type=h:width=50:g=10',
    'soft': 'equalizer=f=1000:width_type=h:width=200:g=-5',
    'treble': 'equalizer=f=14000:width_type=h:width=1000:g=10',
    'vocal': 'equalizer=f=3000:width_type=h:width=1000:g=5'
}

# Configurar PATH para ffmpeg embutido
if getattr(sys, 'frozen', False):
    if hasattr(sys, '_MEIPASS'):
        resource_dir = sys._MEIPASS
    else:
        resource_dir = os.path.join(os.path.dirname(sys.executable), '_internal')
    
    # Add to system PATH for subprocesses (yt-dlp finding ffmpeg)
    os.environ["PATH"] += os.pathsep + resource_dir

def parse_time(time_str):
    if not time_str or time_str.strip() == "": return None
    try:
        parts = list(map(int, time_str.split(':')))
        if len(parts) == 1: return parts[0] # Seconds
        if len(parts) == 2: return parts[0] * 60 + parts[1] # MM:SS
        if len(parts) == 3: return parts[0] * 3600 + parts[1] * 60 + parts[2] # HH:MM:SS
    except:
        return None
    return None

# Globais para progresso
current_progress = {
    "percent": 0,
    "status": "idle"
}

def progress_hook(d):
    global current_progress
    if d['status'] == 'downloading':
        try:
            p = d.get('_percent_str', '0%').replace('%','')
            current_progress['percent'] = float(p)
            current_progress['status'] = 'downloading'
        except:
            pass
    elif d['status'] == 'finished':
        current_progress['percent'] = 100
        current_progress['status'] = 'processing'

# Helper for Persistence (EXE vs Script)
def get_base_dir():
    if getattr(sys, 'frozen', False):
        return os.path.dirname(sys.executable)
    return os.path.dirname(os.path.abspath(__file__))

HISTORY_FILE = os.path.join(get_base_dir(), 'history.json')

def load_history():
    if not os.path.exists(HISTORY_FILE):
        return []
    try:
        with open(HISTORY_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    except:
        return []

def save_to_history(item):
    history = load_history()
    # Add timestamp
    item['timestamp'] = datetime.now().isoformat()
    # Prepend new item
    history.insert(0, item)
    # Keep last 50
    history = history[:50]
    with open(HISTORY_FILE, 'w', encoding='utf-8') as f:
        json.dump(history, f, ensure_ascii=False, indent=2)

# Rotas


@app.post("/info")
async def get_info(request: DownloadRequest):
    try:
        url = request.url
        is_magic = False
        magic_source = None

        # Spotify/Apple Music "Magic Search" Logic
        if "spotify.com" in url or "music.apple.com" in url:
            try:
                print(f"Detectando Magic Search para: {url}")
                
                # Fetch Page Title
                # Note: verify ssl=False implicit in some envs or handle if needed
                req = Request(url, headers={'User-Agent': 'Mozilla/5.0'})
                html = urlopen(req).read().decode('utf-8')
                
                # Extract Title Regex
                title_match = re.search(r'<title>(.*?)</title>', html, re.IGNORECASE)
                if title_match:
                    page_title = title_match.group(1)
                    # Clean title (remove " | Spotify", " on Apple Music", etc)
                    clean_title = re.sub(r' \| Spotify.*', '', page_title)
                    clean_title = re.sub(r' on Apple Music.*', '', clean_title)
                    # Remove common prefixes
                    clean_title = clean_title.replace("Song ·", "").replace("Album ·", "")
                    
                    # Convert to YouTube Search
                    # "Song - Artist" -> "ytsearch1:Song Artist audio"
                    url = f"ytsearch1:{clean_title} audio"
                    is_magic = True
                    magic_source = "Spotify" if "spotify.com" in request.url else "Apple Music"
                    print(f"Convertido para: {url}")
            except Exception as e:
                print(f"Erro no Magic Search: {e}")
                # Fallback to normal URL (will likely fail in yt-dlp but we try)

        ydl_opts = {
            'quiet': False, # Logs ativados
            'nocheckcertificate': True,
            'ignoreerrors': False, # Mostrar erro real
            'no_warnings': False,
            'js_runtimes': {'node': {}},
            'noplaylist': False,  # Allow playlist detection
            'extract_flat': 'in_playlist', # Fast extraction for playlists
            'cookiefile': os.path.join(get_base_dir(), 'cookies.txt'),
            'extractor_args': {
                'youtube': {
                    'player_client': ['tv'],
                }
            }
        }
        
        # If Magic Search, we need full info to return the first result
        # 'extract_flat' is often used for speed but for search we need details
        
        # Try multiple clients to bypass Age Gates / Bot Detection / 403 Errors
        clients = ['tv', 'android', 'ios', 'web']
        success = False
        last_error = None
        
        for client in clients:
            try:
                print(f"Tentando extração com cliente: {client}")
                if client == 'web':
                     # 'web' means default behavior (no specific player_client arg)
                     if 'extractor_args' in ydl_opts:
                         del ydl_opts['extractor_args']
                else:
                     ydl_opts['extractor_args'] = {'youtube': {'player_client': [client]}}
                
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    info = ydl.extract_info(url, download=False)
                
                success = True
                break # If successful, stop trying
            except Exception as e:
                print(f"Falha com cliente '{client}': {e}")
                last_error = e
        
        if not success:
             print("Todas as tentativas de cliente falharam.")
             if last_error:
                 raise last_error

        # Handle Search Results
        if is_magic and 'entries' in info:
            try:
                info = info['entries'][0]
            except IndexError:
                raise HTTPException(status_code=404, detail="Música não encontrada no YouTube.")
            
        # Detect if it's a playlist (either a full list or a video inside a list)
        is_playlist = ('entries' in info or info.get('playlist_id')) and not is_magic 
        
        # Duration String Logic
        duration_str = info.get('duration_string')
        if not duration_str and info.get('duration'):
            import datetime
            duration_str = str(datetime.timedelta(seconds=info['duration']))
            if duration_str.startswith('0:'): duration_str = duration_str[2:] 

        # Extract resolutions
        resolutions = []
        if not is_magic:
            formats = info.get('formats', [])
            
            # If playlist, formats might be in the first entry
            if not formats and is_playlist and 'entries' in info and info['entries']:
                 first_entry = info['entries'][0]
                 formats = first_entry.get('formats', [])
                 
                 # if still no formats (due to flat extraction), fetch explicit info for first video
                 if not formats:
                     try:
                         first_url = first_entry.get('url') or first_entry.get('webpage_url')
                         if first_url:
                             # Use a new YDL instance to avoid conflicts and ensure full extraction
                             with yt_dlp.YoutubeDL({'quiet':True, 'noplaylist': True}) as ydl_temp:
                                 v_info = ydl_temp.extract_info(first_url, download=False)
                                 formats = v_info.get('formats', [])
                     except:
                         pass

            res_set = set()
            for f in formats:
                if f.get('vcodec') != 'none' and f.get('height'):
                    res_set.add(f['height'])
            resolutions = sorted(list(res_set), reverse=True)

        return {
            "status": "success",
            "title": info.get('title'),
            "thumbnail": info.get('thumbnail'),
            "url": info.get('webpage_url', request.url), # Return resolved URL
            "resolutions": resolutions,
            "is_playlist": is_playlist,
            "duration": info.get('duration'),
            "duration_string": duration_str,
            "magic_source": magic_source
        }

    except HTTPException as he:
        raise he
    except Exception as e:
        import traceback
        error_msg = f"ERROR in /info: {str(e)}\n\n{traceback.format_exc()}"
        print(error_msg)
        try:
             with open(os.path.join(get_base_dir(), "debug_info.txt"), "w", encoding="utf-8") as f:
                f.write(error_msg)
        except:
             pass

        print(f"Erro ao obter info: {e}")
        if "spotify.com" in request.url:
             raise HTTPException(status_code=400, detail="Não foi possível ler este link do Spotify. Tente colar o nome da música.")
        raise HTTPException(status_code=500, detail=str(e))

# Novo endpoint para detalhes de playlist
# Este código deve ser adicionado ao main.py após o endpoint /info (linha ~298)

@app.post("/playlist/details")
def get_playlist_details(request: InfoRequest):
    """
    Retorna lista detalhada de todos os vídeos em uma playlist
    """
    try:
        url = request.url
        
        ydl_opts = {
            'quiet': False,
            'nocheckcertilicate': True,
            'ignoreerrors': True,  # Continue mesmo se algum vídeo falhar
            'no_warnings': False,
            'js_runtimes': {'node': {}},
            'extract_flat': 'in_playlist',  # Extração rápida
            'cookiefile': os.path.join(get_base_dir(), 'cookies.txt'),
        }
        
        # Tentar diferentes clientes
        clients = ['tv', 'android', 'web']
        success = False
        playlist_info = None
        
        for client in clients:
            try:
                print(f"Fetching playlist with client: {client}")
                if client == 'web':
                    if 'extractor_args' in ydl_opts:
                        del ydl_opts['extractor_args']
                else:
                    ydl_opts['extractor_args'] = {'youtube': {'player_client': [client]}}
                
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    playlist_info = ydl.extract_info(url, download=False)
                
                success = True
                break
            except Exception as e:
                print(f"Failed with client '{client}': {e}")
                continue
        
        if not success or not playlist_info:
            raise HTTPException(status_code=500, detail="Falha ao carregar playlist")
        
        # Verificar se é realmente uma playlist
        if 'entries' not in playlist_info:
            raise HTTPException(status_code=400, detail="URL não é uma playlist")
        
        # Processar vídeos
        videos = []
        for idx, entry in enumerate(playlist_info['entries']):
            if entry is None:  # Vídeo privado/deletado
                continue
                
            # Formatar duração
            duration = entry.get('duration', 0)
            duration_str = entry.get('duration_string', '0:00')
            if not duration_str and duration:
                import datetime
                duration_str = str(datetime.timedelta(seconds=duration))
                if duration_str.startswith('0:'):
                    duration_str = duration_str[2:]
            
            videos.append({
                "index": idx,
                "id": entry.get('id', ''),
                "title": entry.get('title', 'Sem título'),
                "thumbnail": entry.get('thumbnail') or entry.get('thumbnails', [{}])[0].get('url'),
                "duration": duration,
                "duration_string": duration_str,
                "uploader": entry.get('uploader', entry.get('channel', 'Desconhecido')),
                "url": entry.get('url') or entry.get('webpage_url') or f"https://www.youtube.com/watch?v={entry.get('id')}"
            })
        
        return {
            "status": "success",
            "playlist_id": playlist_info.get('id', ''),
            "title": playlist_info.get('title', 'Playlist'),
            "total_videos": len(videos),
            "uploader": playlist_info.get('uploader', playlist_info.get('channel', 'Desconhecido')),
            "videos": videos
        }
    
    except HTTPException as he:
        raise he
    except Exception as e:
        import traceback
        error_msg = f"ERROR in /playlist/details: {str(e)}\n\n{traceback.format_exc()}"
        print(error_msg)
        raise HTTPException(status_code=500, detail=str(e))



@app.get("/progress")
def get_progress():
    return current_progress

@app.post("/open_folder")
def open_folder():
    downloads_dir = os.path.join(os.getcwd(), "downloads")
    if os.path.exists(downloads_dir):
        os.startfile(downloads_dir)
    return {"status": "opened"}

@app.post("/download")
def download_music(request: DownloadRequest):
    global current_progress
    current_progress['percent'] = 0
    current_progress['status'] = 'starting'
    
    try:
        downloads_dir = os.path.join(get_base_dir(), "downloads")
        os.makedirs(downloads_dir, exist_ok=True)

        format_str = 'bestaudio/best'
        postprocessors = []

        # ... (lógica de formato existente igual)
        if request.mode == 'video':
            format_str = 'bestvideo+bestaudio/best'
            if request.quality == '4k':
                format_str = 'bestvideo+bestaudio/best'
            elif request.quality.endswith('p') and request.quality[:-1].isdigit():
                height = int(request.quality[:-1])
                format_str = f'bestvideo[height<={height}]+bestaudio/best[height<={height}]'
            
            postprocessors.append({'key': 'EmbedThumbnail'})
            postprocessors.append({'key': 'FFmpegMetadata'})

        else:
            if request.quality == 'flac':
                 postprocessors.append({
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': 'flac',
                })
            elif request.quality == 'best': 
                 postprocessors.append({
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': 'm4a', 
                })
            elif request.quality == 'high':  
                 postprocessors.append({
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': 'mp3',
                    'preferredquality': '192',
                })
            elif request.quality == 'medium':
                 postprocessors.append({
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': 'mp3',
                    'preferredquality': '128',
                })
            else: 
                 postprocessors.append({
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': 'mp3',
                    'preferredquality': '320',
                })

            postprocessors.append({'key': 'EmbedThumbnail'})
            postprocessors.append({'key': 'FFmpegMetadata'})

        # Resource Path (Bundled binaries like ffmpeg)
        resource_dir = os.path.dirname(os.path.abspath(__file__))
        if getattr(sys, 'frozen', False):
            if hasattr(sys, '_MEIPASS'):
                resource_dir = sys._MEIPASS
            else:
                resource_dir = os.path.join(os.path.dirname(sys.executable), '_internal')

        # Data Path (Persistent files like cookies/downloads)
        data_dir = get_base_dir()

        # Ranges Logic
        download_ranges = None
        start_sec = parse_time(request.start_time)
        end_sec = parse_time(request.end_time)
        
        if start_sec is not None or end_sec is not None:
             # Logic continues... (omitted for brevity if not changing)
             pass
        
        # We need to re-import ranges logic helper if needed or just use what's there.
        # Ideally I just replace the path setup and options dict.
        
        import yt_dlp.utils
        def range_func(info_dict, ydl):
            return [{'start_time': start_sec, 'end_time': end_sec}]
        
        if start_sec is not None or end_sec is not None:
            download_ranges = range_func

        # Audio Filters (Pitch, Speed, EQ) - (Already Implemented)
        # ... (Assuming unchanged, but I need to be careful not to overwrite valuable logic with ellipsis)

        # Let's target specific lines to be safe.
        # Replacing 'base_dir' def and 'ydl_opts' construction.
        
        pass # Placeholder logic for tool call construction below

        # Audio Pitch & Speed Logic
        # Audio Filters (Pitch, Speed, EQ)
        postprocessor_args = {}
        af_filters = []

        # 1. Pitch & Speed
        if request.pitch != 0 or request.speed != 1.0:
             pitch_factor = 2 ** (request.pitch / 12.0)
             new_rate = int(44100 * pitch_factor)
             
             required_atempo = request.speed / pitch_factor
             
             atempos = []
             while required_atempo > 2.0:
                 atempos.append(2.0)
                 required_atempo /= 2.0
             while required_atempo < 0.5:
                 atempos.append(0.5)
                 required_atempo /= 0.5
             atempos.append(required_atempo)
             
             af_filters.append(f"asetrate={new_rate}")
             for t in atempos:
                  af_filters.append(f"atempo={t}")
             af_filters.append("aresample=44100")

        # 2. Equalizer
        if request.eq_preset and request.eq_preset in EQ_PRESETS:
             af_filters.append(EQ_PRESETS[request.eq_preset])

        if af_filters:
             af_string = ",".join(af_filters)
             postprocessor_args = {
                 'ffmpeg': ['-af', af_string]
             }

        class MyLogger:
            def debug(self, msg):
                with open("yt_dlp.log", "a", encoding="utf-8") as f:
                    f.write(f"[DEBUG] {msg}\n")
            def warning(self, msg):
                with open("yt_dlp.log", "a", encoding="utf-8") as f:
                    f.write(f"[WARNING] {msg}\n")
            def error(self, msg):
                with open("yt_dlp.log", "a", encoding="utf-8") as f:
                    f.write(f"[ERROR] {msg}\n")

        ydl_opts = {
            'format': format_str,
            'outtmpl': os.path.join(downloads_dir, '%(title)s.%(ext)s'),
            'quiet': False, 
            'logger': MyLogger(),
            'nocheckcertificate': True,
            'ignoreerrors': False, 
            'no_warnings': False, 
            'writethumbnail': True, 
            'ffmpeg_location': resource_dir, 
            'postprocessors': postprocessors,
            'postprocessor_args': postprocessor_args,
            'progress_hooks': [progress_hook],
            'noplaylist': not request.playlist,
            'merge_output_format': 'mp4' if request.mode == 'video' else None,
            'js_runtimes': {'node': {}}, 
            'extract_flat': False,
            
            # Manual Cookies File - The most reliable method
            'cookiefile': os.path.join(data_dir, 'cookies.txt'),
            'extractor_args': {
                'youtube': {
                    'player_client': ['tv'],
                }
            }
        }

        # Add ranges only if they exist (prevents NoneType error with force_keyframes)
        if download_ranges:
            ydl_opts['download_ranges'] = download_ranges
            ydl_opts['force_keyframes_at_cuts'] = True
        
        # Metadata Logic - Disable default thumbnail behavior if custom cover
        if request.cover_path:
            ydl_opts['writethumbnail'] = False
            # Remove EmbedThumbnail processing to avoid conflict
            postprocessors = [p for p in postprocessors if p.get('key') != 'EmbedThumbnail']
            ydl_opts['postprocessors'] = postprocessors

        # Check if cookie file exists to warn user (optional logging)
        if not os.path.exists(os.path.join(data_dir, 'cookies.txt')):
             print("AVISO: cookies.txt não encontrado. O download pode falhar com erro 403.")
        
        # Try multiple clients to bypass Age Gates / Bot Detection / 403 Errors
        clients = ['tv', 'android', 'ios', 'web']
        success = False
        last_error = None
        info = None
        final_filename = None
        
        for client in clients:
            try:
                print(f"Tentando download com cliente: {client}")
                if client == 'web':
                     # 'web' means default behavior (no specific player_client arg)
                     if 'extractor_args' in ydl_opts:
                         del ydl_opts['extractor_args']
                else:
                     ydl_opts['extractor_args'] = {'youtube': {'player_client': [client]}}
                
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    info = ydl.extract_info(request.url, download=True)
                    
                    # Process info inside the with block while ydl is in scope
                    if 'entries' in info:
                        info = info['entries'][0]
                    
                    filename = ydl.prepare_filename(info)
                    final_filename = os.path.splitext(os.path.basename(filename))[0]
                    
                    if request.mode == 'video':
                        final_filename += '.mp4'
                    elif request.quality == 'flac':
                        final_filename += '.flac'
                    elif request.quality == 'best':
                        final_filename += '.m4a'
                    else:
                        final_filename += '.mp3'
                
                success = True
                break # If successful, stop trying
            except Exception as e:
                print(f"Falha de download com cliente '{client}': {e}")
                last_error = e
        
        if not success:
             print("Todas as tentativas de download falharam.")
             if last_error:
                 raise last_error

        # POST-PROCESSING: Apply Metadata (Cover, Title, Artist)
        if request.title or request.artist or request.cover_path:
            try:
                output_file = os.path.join(downloads_dir, final_filename)
                if os.path.exists(output_file):
                    temp_output = os.path.join(downloads_dir, f"tagged_{final_filename}")
                    
                    cmd = ['ffmpeg', '-y', '-i', output_file]
                    
                    # Add Cover input
                    if request.cover_path and os.path.exists(request.cover_path):
                        cmd.extend(['-i', request.cover_path])
                        cmd.extend(['-map', '0:0', '-map', '1:0'])
                        cmd.extend(['-c', 'copy'])
                        cmd.extend(['-id3v2_version', '3'])
                        cmd.extend(['-metadata:s:v', 'title=Album cover', '-metadata:s:v', 'comment=Cover (front)'])
                    else:
                        cmd.extend(['-c', 'copy'])
                    
                    if request.title:
                        cmd.extend(['-metadata', f'title={request.title}'])
                    if request.artist:
                        cmd.extend(['-metadata', f'artist={request.artist}'])
                        
                    cmd.append(temp_output)
                    
                    # Execute
                    subprocess.run(cmd, check=True, capture_output=True)
                    
                    # Replace
                    os.replace(temp_output, output_file)
            except Exception as e:
                 print(f"Erro ao aplicar tags: {e}")
                 # Non-fatal error

        # Save to History
        try:
            save_to_history({
                "title": request.title if request.title else info.get('title'),
                "artist": request.artist if request.artist else info.get('artist'),
                "thumbnail": info.get('thumbnail'),
                "file": final_filename,
                "quality": request.quality,
                "mode": request.mode,
                "original_url": request.url
            })
        except Exception as e:
            print(f"Erro ao salvar histórico: {e}")

            return {
                "status": "success", 
                "title": request.title if request.title else info.get('title'), 
                "quality": request.quality,
                "file": final_filename
            }

    except Exception as e:
        import traceback
        error_msg = f"ERROR in /download: {str(e)}\n\n{traceback.format_exc()}"
        print(error_msg)
        try:
             with open(os.path.join(get_base_dir(), "debug_download_error.txt"), "w", encoding="utf-8") as f:
                f.write(error_msg)
        except:
             pass
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/history")
def get_history():
    return load_history()

@app.delete("/history")
def clear_history():
    if os.path.exists(HISTORY_FILE):
        os.remove(HISTORY_FILE)
    return {"status": "cleared"}

@app.get("/auth_status")
def get_auth_status():
    cookie_path = os.path.join(get_base_dir(), "cookies.txt")
    if os.path.exists(cookie_path) and os.path.getsize(cookie_path) > 0:
        return {"authenticated": True}
    return {"authenticated": False}

@app.post("/open_folder")
def open_folder():
    downloads_dir = os.path.join(get_base_dir(), "downloads")
    if os.path.exists(downloads_dir):
        os.startfile(downloads_dir)
    return {"status": "opened"}

from fastapi import File, UploadFile
import shutil

@app.post("/upload_cookies")
async def upload_cookies(file: UploadFile = File(...)):
    try:
        cookie_path = os.path.join(get_base_dir(), "cookies.txt")
        
        with open(cookie_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
            
        return {"status": "success", "message": "Cookies atualizados com sucesso!"}
    except Exception as e:
        print(f"Erro no upload: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/upload_cover")
async def upload_cover(file: UploadFile = File(...)):
    try:
        temp_dir = os.path.join(get_base_dir(), "temp_covers")
        os.makedirs(temp_dir, exist_ok=True)
        
        # Save with original extension
        ext = os.path.splitext(file.filename)[1]
        if not ext: ext = ".jpg"
        
        # Unique name
        import uuid
        filename = f"{uuid.uuid4()}{ext}"
        filepath = os.path.join(temp_dir, filename)
        
        with open(filepath, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
            
        return {"status": "success", "path": filepath}
    except Exception as e:
        print(f"Erro no upload da capa: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# App Execution and Static Files
# App Execution and Static Files
if getattr(sys, 'frozen', False):
    if hasattr(sys, '_MEIPASS'):
        static_dir = os.path.join(sys._MEIPASS, 'static')
    else:
        static_dir = os.path.join(os.path.dirname(sys.executable), '_internal', 'static')
else:
    static_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static')

# Only mount if directory exists (in .exe or if manually built)
if os.path.exists(static_dir):
    app.mount("/", StaticFiles(directory=static_dir, html=True), name="static")

if __name__ == "__main__":
    try:
        import uvicorn
        import multiprocessing
        import webbrowser
        import threading
        import time

        # Freeze support for exe
        multiprocessing.freeze_support()
        
        # Open browser automatically
        def open_browser():
            time.sleep(2)
            webbrowser.open("http://localhost:8000")
            
        threading.Thread(target=open_browser, daemon=True).start()
        
        print("Iniciando servidor...")
        uvicorn.run(app, host="0.0.0.0", port=8000)
        
    except Exception as e:
        import traceback
        error_msg = f"CRASH: {str(e)}\n\n{traceback.format_exc()}"
        print(error_msg)
        with open("crash_log.txt", "w", encoding="utf-8") as f:
            f.write(error_msg)
        input("Pressione ENTER para fechar...")
